# Exercise 3 - Basic Antivirus Evasion

## Description

Implement one or more of the described evasion techniques in your shellcode loader / injector and test it against AV.

## Tips

There is no 'golden bullet' for this exercise, as AV could detect a variety of aspects of your loader. Additionally, indicators used by AV are ever-changing and could be completely different tomorrow! Some key points for discussing AV are discussed below, but do reference the workshop slides and provided resources for a complete overview.

> ℹ **Note:** It will be slightly easier to make your local shellcode loader evasive, than it will be for your remote shellcode injector. Why not try both?

### Shellcode obfuscation

Shellcodes generated by tools such as `msfvenom` or C2 frameworks are well-known and easy to detect for AV. To counter this, we can encode/encrypt our shellcode, and only decode/decrypt it when we are ready to execute. Encoding means changing the format of data in a reversible manner, and is often used to transmit data (e.g. URL encoding or Base64-encoding). Encryption means altering the data using a mathematical algorithm and secret key. Both are reversible, and usable to change the format of your shellcode. Keep in mind though that algorithms like Base64 are so widely used that AV may decode and inspect it as well.

A common choice for encrypting shellcode is a simple XOR scheme with a one- or multi-byte key. Though not very sturdy in terms of encryption, one of the benefits of XOR is that it is reversible (the function for encryption and decryption are the same), which makes it very easy to implement.

> ℹ **Note:** Note that encrypting a very large blob of shellcode will increase the [entropy](https://malwaretips.com/threads/malware-analysis-2-what-is-entropy-and-how-do-i-find-the-entropy-of-a-file.42333/) of your file, which could become an indicator of maliciousness. Consider using different encoding schemes, such as encoding your encrypted shellcode to a string with English words, to help mitigate this.

### String obfuscation

Strings that are defined within your code are saved in the binary itself. That means that defining string variables with suspicious contents (such as suspicious function names or patterns, or known-bad strings such as malware names) are easily detectable by AV. To counter this, we can store an encoded or encrypted variant of said strings in the binary, and only decode/decrypt them when they are needed. The process and considerations for doing so are the same as outlined above.

### Function call obfuscation

> ℹ **Note:** If you are using Nim, this section is less relevant. Nim automatically resolves functions dynamically through it's Foreign Function Interface (FFI, more information [here](https://github.com/byt3bl33d3r/OffensiveNim#opsec-considerations)), meaning you don't have to manually obfuscate your function calls. Very beneficial for malware authors!

AV often analyses the functions used by a binary via the Import Address Table (IAT). If a set of suspicious functions, such as the ones we discussed in the previous modules, are used in conjunction by a binary, AV is likely to classify this binary as suspicious and quarantine it (or at least scrutinize it for further analysis). To prevent function calls from showing up in the IAT, we can obfuscate function calls by resolving them dynamically. This can be done by using the `GetModuleHandle()` and `GetProcAddress()` Windows APIs to resolve the function address, and subsequently calling it with the right function definition from MSDN (e.g. [VirtualProtect](https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualprotect)). Keep in mind that any strings used for dynamically resolving function calls will also show up in your binary! Consider obfuscating or encrypting these strings to get rid of another indicator.

Alternatively, you can make use of libraries that help invoke functions dynamically, such as [D/Invoke](https://github.com/TheWover/DInvoke) for C# or [NimlineWhispers](https://github.com/ajpc500/NimlineWhispers2) for Nim. These libraries either resolve and call functions at runtime, or implement the functions themselves, which helps evade both static function import analysis as well as dynamic analysis by AV and EDR. Also refer to [bonus exercise 3](../BONUS%20Exercise%203%20-%20Basic%20EDR%20Evasion/).

### Bypassing dynamic analysis

Because AV has limited resources to deal with, expensive scanning operations are usually only performed on suspicious processes. We can abuse the shortcuts an AV takes, for example by only detonating our payload when it matches the target environment ("payload keying"), performing innocent operations until a sandbox environment times out (30-60s), or making our malicious code look benign when we expect an AV to scan it (e.g. [suspended thread injection](https://github.com/plackyhacker/Suspended-Thread-Injection)). There really is no limit in deploying these bypasses, except your creativity!

### Testing against AV

Testing against AV (and EDR) products can be frustrating at times, since vendors purposely limit available technical information about their detections. Sites like [VirusTotal](https://www.virustotal.com/) can be used to check against a number of AV products, but testing your malware on them is **not advised** since submitted samples are shared with defenders (which will cause your malware to be analyzed and fingerprinted). [Antiscan](https://antiscan.me) promises to deliver this service without sample submission, but shady sites can never be trusted, right? :)

A viable alternative for testing against Windows Defender is [ThreatCheck](https://github.com/rasta-mouse/ThreatCheck). This tool splits up your binary until it finds the bytes which Defender (or the Antimalware Scan Interface, AMSI) flags on. This will allow you to identify the part of your binary that is considered malicious. The result could be a string which is easy to fix, but it could also be a collection of combined instructions which makes it harder to fix.

### Golang tips

The library `golang.org/x/sys/windows` is the official library of Golang that implements the Windows API. However, some unusual APIs that we are using in malware development may be missing from this library. For example, the `VirtualAllocEx` or `CreateRemoteThread` functions are not available.

To implement these functions in our code, we can use the `golang.org/x/sys/windows/mkwinsyscall` package to generate a file (usually [`zsyscall_windows.go`](https://github.com/golang/sys/blob/master/windows/zsyscall_windows.go) generated from [`syscall_windows.go`](https://github.com/golang/sys/blob/c0bba94af5f85fbad9f6dc2e04ed5b8fac9696cf/windows/syscall_windows.go#L168)) that will contain all our Windows APIs implemented in Golang.

To generate the right input line for `mkwinsyscall`, we need to get the syntax of the function. Fortunately, this one is documented on [Microsoft](https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createremotethreadex):
```
HANDLE CreateRemoteThread(
  [in]  HANDLE                 hProcess,
  [in]  LPSECURITY_ATTRIBUTES  lpThreadAttributes,
  [in]  SIZE_T                 dwStackSize,
  [in]  LPTHREAD_START_ROUTINE lpStartAddress,
  [in]  LPVOID                 lpParameter,
  [in]  DWORD                  dwCreationFlags,
  [out] LPDWORD                lpThreadId
);
```

The corresponding line for `mkwinsyscall` is the following

```golang
//sys	CreateRemoteThread(process Handle, threadAttributes *SecurityAttributes, stackSize uintptr, startAddress uintptr, lpParameter uintptr, dwCreationFlags uint32, lpThreadId *uint32) (threadHandle windows.Handle, err error) = kernel32.CreateRemoteThread
```

This is basically the prototype of the Golang function with at the end the location of the function in the Windows API, in our case `kernel32.CreateRemoteThread`.
The tricky part is to translate each `C` type into a Golang type. To simplify the process, you can look at the existing lines in Windows package and if something is wrong debug with a tool like [APIMonitor](https://apimonitor.com/) and compare with a working call of the API.

Finally, make sure to add the following line in `syscall_windows.go`
```golang
//go:generate go run golang.org/x/sys/windows/mkwinsyscall -output zsyscall_windows.go syscall_windows.go
```

And then, the file `zsyscall_windows.go` can be generated with:
```bash
go generate syscall_windows.go
```

These steps can be time-consuming, but meanwhile the windows package is updated you can find several of the API already implemented in the [go-windows](https://github.com/nodauf/go-windows) repository

## References

### Generic

- [Evasions](https://evasions.checkpoint.com/)

### C#

- [D/Invoke](https://github.com/TheWover/DInvoke)
- [Emulating Covert Operations - Dynamic Invocation (Avoiding PInvoke & API Hooks)](https://thewover.github.io/Dynamic-Invoke/)
- [Dynamic Invocation in .NET to bypass hooks](https://blog.nviso.eu/2020/11/20/dynamic-invocation-in-net-to-bypass-hooks/)
- [CheckPlease - C#](https://github.com/Arvanaghi/CheckPlease/tree/master/C%23)
- [encryptedShellcodeWrapper.cs](https://github.com/Arno0x/ShellcodeWrapper/blob/master/templates/encryptedShellcodeWrapper.cs)
- [ConfuserEx](https://github.com/mkaring/ConfuserEx)

### Nim

- [NimlineWhispers2](https://github.com/ajpc500/NimlineWhispers2) or [NimlineWhispers3](https://github.com/klezVirus/NimlineWhispers3)
- [suspended_thread_injection.nim](https://github.com/byt3bl33d3r/OffensiveNim/blob/master/src/suspended_thread_injection.nim)
- [Denim](https://github.com/moloch--/denim)

## Solution
Example solutions are provided in the [solutions folder](solutions/) ([C#](solutions/csharp/), [Nim](solutions/nim/)). Keep in mind that there is no "right" answer, if you made it work that's a valid solution!

> ℹ **Note:** The example solution may be detected by AV due to the fact that it is available publicly. You should be able to bypass antivirus by using similar techniques though!